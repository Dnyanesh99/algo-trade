feature_repo:
  insert_features: |
    INSERT INTO features (ts, instrument_id, timeframe, feature_name, feature_value)
    VALUES ($1, $2, $3, $4, $5)
    ON CONFLICT (instrument_id, timeframe, feature_name, ts) DO UPDATE
    SET feature_value = EXCLUDED.feature_value
  get_features: |
    SELECT ts, feature_name, feature_value
    FROM features
    WHERE instrument_id = $1 AND timeframe = $2 AND ts BETWEEN $3 AND $4
    ORDER BY ts ASC, feature_name ASC
  get_latest_features: |
    SELECT ts, feature_name, feature_value
    FROM features
    WHERE instrument_id = $1 AND timeframe = $2 AND ts = (
        SELECT MAX(ts) FROM features WHERE instrument_id = $1 AND timeframe = $2
    )
    ORDER BY feature_name ASC
  get_latest_n_features: |
    SELECT ts, feature_name, feature_value
    FROM features
    WHERE instrument_id = $1 AND timeframe = $2
    ORDER BY ts DESC
    LIMIT $3
  get_training_data: |
    SELECT f.ts, f.feature_name, f.feature_value, l.label
    FROM features f
    LEFT JOIN labels l ON f.ts = l.ts AND f.instrument_id = l.instrument_id AND f.timeframe = l.timeframe
    WHERE f.instrument_id = $1 AND f.timeframe = $2 AND f.ts BETWEEN $3 AND $4
    ORDER BY f.ts, f.feature_name
  get_multiframe_training_data: |
    WITH labeled_timestamps AS (
        SELECT ts, label
        FROM labels
        WHERE instrument_id = $1
          AND timeframe = $2
          AND ts BETWEEN $3 AND $4
    ),
    timeframe_aligned_features AS (
        SELECT
            lt.ts,
            lt.label,
            f.timeframe || '_' || f.feature_name AS feature_key,
            f.feature_value
        FROM labeled_timestamps lt
        CROSS JOIN LATERAL (
            -- 15min features (exact timestamp match)
            SELECT '15min' AS timeframe, feature_name, feature_value
            FROM features
            WHERE instrument_id = $1
              AND timeframe = '15min'
              AND ts = lt.ts

            UNION ALL

            -- 5min features (latest available before or at label time)
            SELECT '5min' AS timeframe, feature_name, feature_value
            FROM features f5
            WHERE f5.instrument_id = $1
              AND f5.timeframe = '5min'
              AND f5.ts = (
                  SELECT MAX(ts)
                  FROM features
                  WHERE instrument_id = $1
                    AND timeframe = '5min'
                    AND ts <= lt.ts
              )

            UNION ALL

            -- 60min features (latest available before or at label time)
            SELECT '60min' AS timeframe, feature_name, feature_value
            FROM features f60
            WHERE f60.instrument_id = $1
              AND f60.timeframe = '60min'
              AND f60.ts = (
                  SELECT MAX(ts)
                  FROM features
                  WHERE instrument_id = $1
                    AND timeframe = '60min'
                    AND ts <= lt.ts
              )
        ) f
    )
    SELECT
        ts,
        label,
        feature_key,
        feature_value
    FROM timeframe_aligned_features
    ORDER BY ts, feature_key
  insert_engineered_features: |
    INSERT INTO engineered_features
    (instrument_id, timeframe, timestamp, feature_name, feature_value,
      generation_method, source_features, quality_score)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    ON CONFLICT (timestamp, instrument_id, timeframe, feature_name)
    DO UPDATE SET
        feature_value = EXCLUDED.feature_value,
        generation_method = EXCLUDED.generation_method,
        source_features = EXCLUDED.source_features,
        quality_score = EXCLUDED.quality_score
  insert_feature_scores: |
    INSERT INTO feature_scores
    (instrument_id, timeframe, training_timestamp, feature_name, importance_score,
      stability_score, consistency_score, composite_score, model_version)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    ON CONFLICT (instrument_id, timeframe, feature_name, training_timestamp)
    DO UPDATE SET
        importance_score = EXCLUDED.importance_score,
        stability_score = EXCLUDED.stability_score,
        consistency_score = EXCLUDED.consistency_score,
        composite_score = EXCLUDED.composite_score,
        model_version = EXCLUDED.model_version
  get_latest_feature_selection: |
    SELECT selected_features
    FROM feature_selection_history
    WHERE instrument_id = $1 AND timeframe = $2
    ORDER BY selection_timestamp DESC
    LIMIT 1
  insert_feature_selection_history: |
    INSERT INTO feature_selection_history
    (instrument_id, timeframe, selection_timestamp, selected_features,
      selection_criteria, total_features_available, features_selected,
      selection_method, model_version)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)

instrument_repo:
  insert_instrument: |
    INSERT INTO instruments (
        instrument_token, exchange_token, tradingsymbol, name, last_price,
        expiry, strike, tick_size, lot_size, instrument_type, segment, exchange,
        freeze_quantity, underlying_key, underlying_type, underlying_symbol, minimum_lot, weekly, last_updated
    ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, NOW()
    ) RETURNING instrument_id;
  update_instrument: |
    UPDATE instruments SET
        instrument_token = $1, exchange_token = $2, tradingsymbol = $3, name = $4, last_price = $5,
        expiry = $6, strike = $7, tick_size = $8, lot_size = $9, instrument_type = $10, segment = $11,
        exchange = $12, last_updated = NOW()
    WHERE instrument_id = $13;
  get_instrument_by_tradingsymbol: "SELECT * FROM instruments WHERE tradingsymbol = $1 AND exchange = $2;"
  get_instrument_by_token: "SELECT * FROM instruments WHERE instrument_token = $1;"
  get_instrument_by_id: "SELECT * FROM instruments WHERE instrument_id = $1;"
  get_all_instruments: "SELECT * FROM instruments;"
  get_instruments_by_type: "SELECT * FROM instruments WHERE instrument_type = $1 AND exchange = $2;"

label_repo:
  insert_labels: |
    INSERT INTO labels (ts, instrument_id, timeframe, label, tp_price, sl_price, exit_price, exit_reason, exit_bar_offset, barrier_return, path_adjusted_return, max_favorable_excursion, max_adverse_excursion, risk_reward_ratio, volatility_at_entry)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
    ON CONFLICT (instrument_id, timeframe, ts) DO UPDATE
    SET label = EXCLUDED.label,
        tp_price = EXCLUDED.tp_price,
        sl_price = EXCLUDED.sl_price,
        exit_price = EXCLUDED.exit_price,
        exit_reason = EXCLUDED.exit_reason,
        exit_bar_offset = EXCLUDED.exit_bar_offset,
        barrier_return = EXCLUDED.barrier_return,
        max_favorable_excursion = EXCLUDED.max_favorable_excursion,
        max_adverse_excursion = EXCLUDED.max_adverse_excursion,
        risk_reward_ratio = EXCLUDED.risk_reward_ratio,
        volatility_at_entry = EXCLUDED.volatility_at_entry
  get_labels: |
    SELECT ts, timeframe, label, tp_price, sl_price, exit_price, exit_reason, exit_bar_offset, barrier_return, max_favorable_excursion, max_adverse_excursion, risk_reward_ratio, volatility_at_entry
    FROM labels
    WHERE instrument_id = $1 AND timeframe = $2 AND ts BETWEEN $3 AND $4
    ORDER BY ts ASC
  get_label_statistics: |
    SELECT
        label,
        COUNT(*) as count,
        AVG(barrier_return) as avg_return,
        STDDEV(barrier_return) as std_return
    FROM labels
    WHERE instrument_id = $1 AND timeframe = $2
    GROUP BY label

ohlcv_repo:
  insert_ohlcv_data: |
    INSERT INTO {table_name} (ts, instrument_id, open, high, low, close, volume, oi)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    ON CONFLICT (instrument_id, ts) DO UPDATE
    SET open = EXCLUDED.open,
        high = EXCLUDED.high,
        low = EXCLUDED.low,
        close = EXCLUDED.close,
        volume = EXCLUDED.volume,
        oi = EXCLUDED.oi
  get_ohlcv_data: "SELECT ts, open, high, low, close, volume, oi FROM {table_name} WHERE instrument_id = $1 AND ts BETWEEN $2 AND $3 ORDER BY ts ASC"
  get_latest_candle: "SELECT ts, open, high, low, close, volume, oi FROM {table_name} WHERE instrument_id = $1 ORDER BY ts DESC LIMIT 1"
  get_ohlcv_data_for_features: "SELECT ts, open, high, low, close, volume, oi FROM {table_name} WHERE instrument_id = $1 ORDER BY ts DESC LIMIT $2"
  check_data_availability: "SELECT COUNT(*) as candle_count FROM {table_name} WHERE ts >= $1 AND ts <= $2"

signal_repo:
  insert_signal: |
    INSERT INTO signals (ts, instrument_id, signal_type, direction, confidence_score, source_feature_name, price_at_signal, source_feature_value, details)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    ON CONFLICT (instrument_id, signal_type, ts) DO UPDATE
    SET direction = EXCLUDED.direction,
        confidence_score = EXCLUDED.confidence_score,
        source_feature_name = EXCLUDED.source_feature_name,
        price_at_signal = EXCLUDED.price_at_signal,
        source_feature_value = EXCLUDED.source_feature_value,
        details = EXCLUDED.details
  get_signals: |
    SELECT ts, signal_type, direction, confidence_score, source_feature_name, price_at_signal, source_feature_value, details
    FROM signals
    WHERE instrument_id = $1 AND ts BETWEEN $2 AND $3
  get_signal_history: |
    SELECT ts, signal_type, direction, confidence_score, price_at_signal
    FROM signals
    WHERE instrument_id = $1
    ORDER BY ts DESC
    LIMIT $2

model_registry:
  insert_model: |
    INSERT INTO model_registry 
    (version, training_end_date, accuracy, f1_score, sharpe_ratio, max_drawdown, 
     total_signals, profitable_signals, config, is_active, instrument_id, model_type, 
     timeframe, deployment_status, feature_count, feature_names, model_file_path, 
     metadata_file_path, training_start_date, training_duration_seconds, 
     feature_importance, model_size_mb, training_data_start_date, training_data_end_date,
     training_samples_count, validation_samples_count, test_samples_count)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, 
            $18, $19, $20, $21, $22, $23, $24, $25, $26, $27)
    RETURNING id
  get_active_model: |
    SELECT id, version, created_at, training_end_date, accuracy, f1_score, 
           sharpe_ratio, max_drawdown, total_signals, profitable_signals, config,
           instrument_id, model_type, timeframe, deployment_status, feature_count,
           feature_names, model_file_path, metadata_file_path, training_start_date,
           training_duration_seconds, feature_importance, model_size_mb
    FROM model_registry 
    WHERE is_active = TRUE
    LIMIT 1
  get_active_models: |
    SELECT id, version, created_at, training_end_date, accuracy, f1_score, 
           sharpe_ratio, max_drawdown, total_signals, profitable_signals, config,
           instrument_id, model_type, timeframe, deployment_status, feature_count,
           feature_names, model_file_path, metadata_file_path, training_start_date,
           training_duration_seconds, feature_importance, model_size_mb
    FROM model_registry 
    WHERE is_active = TRUE
    ORDER BY created_at DESC
  get_model_by_version: |
    SELECT id, version, created_at, training_end_date, accuracy, f1_score,
           sharpe_ratio, max_drawdown, total_signals, profitable_signals, config, is_active
    FROM model_registry 
    WHERE version = $1
  get_model_history: |
    SELECT id, version, created_at, training_end_date, accuracy, f1_score,
           sharpe_ratio, max_drawdown, total_signals, profitable_signals, is_active
    FROM model_registry 
    ORDER BY created_at DESC
    LIMIT $1
  deactivate_all_models: |
    UPDATE model_registry SET is_active = FALSE WHERE is_active = TRUE
  activate_model: |
    UPDATE model_registry SET is_active = TRUE WHERE version = $1
  get_previous_active_model: |
    SELECT id, version, created_at, training_end_date, accuracy, f1_score,
           sharpe_ratio, max_drawdown, total_signals, profitable_signals, config, is_active
    FROM model_registry 
    WHERE created_at < (SELECT created_at FROM model_registry WHERE version = $1)
    ORDER BY created_at DESC
    LIMIT 1
  rollback_to_previous: |
    WITH previous_model AS (
      SELECT version FROM model_registry 
      WHERE created_at < (SELECT created_at FROM model_registry WHERE version = $1)
      ORDER BY created_at DESC
      LIMIT 1
    )
    UPDATE model_registry 
    SET is_active = CASE 
      WHEN version = (SELECT version FROM previous_model) THEN TRUE
      ELSE FALSE
    END
    RETURNING (SELECT version FROM previous_model) as activated_version

chart_repo:
  get_chart_data: |
    SELECT ts, open, high, low, close, volume, oi 
    FROM {table_name} 
    WHERE instrument_id = $1 
    AND ts BETWEEN $2 AND $3 
    ORDER BY ts ASC
  get_chart_data_latest: |
    SELECT ts, open, high, low, close, volume, oi 
    FROM {table_name} 
    WHERE instrument_id = $1 
    ORDER BY ts DESC 
    LIMIT $2
  get_chart_data_with_indicators: |
    SELECT 
      o.ts, o.open, o.high, o.low, o.close, o.volume, o.oi,
      f.feature_name, f.feature_value
    FROM {table_name} o
    LEFT JOIN features f ON o.ts = f.ts AND o.instrument_id = f.instrument_id AND f.timeframe = $4
    WHERE o.instrument_id = $1 
    AND o.ts BETWEEN $2 AND $3
    ORDER BY o.ts ASC
  get_realtime_chart_data: |
    SELECT ts, open, high, low, close, volume, oi 
    FROM {table_name} 
    WHERE instrument_id = $1 
    AND ts > $2 
    ORDER BY ts DESC 
    LIMIT $3
  get_instruments_for_chart: |
    SELECT instrument_id, tradingsymbol, name, exchange, segment, instrument_type, last_price
    FROM instruments 
    WHERE tradingsymbol ILIKE $1 OR name ILIKE $1
    ORDER BY tradingsymbol ASC
    LIMIT $2
  get_chart_data_summary: |
    SELECT 
      COUNT(*) as total_candles,
      MIN(ts) as start_time,
      MAX(ts) as end_time,
      MIN(low) as min_price,
      MAX(high) as max_price,
      SUM(volume) as total_volume
    FROM {table_name}
    WHERE instrument_id = $1
    AND ts BETWEEN $2 AND $3
  check_table_exists: |
    SELECT EXISTS (
        SELECT 1
        FROM information_schema.tables
        WHERE table_name = $1
    )

migrate:
  create_migrations_table: |
    CREATE TABLE IF NOT EXISTS schema_migrations (
        version VARCHAR(50) PRIMARY KEY,
        executed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        execution_time_ms INTEGER NOT NULL
    );
  get_applied_migrations: "SELECT version FROM schema_migrations ORDER BY executed_at"
  insert_migration: "INSERT INTO schema_migrations (version, execution_time_ms) VALUES ($1, $2)"


label_stats_repo:
  insert_stats: |
    INSERT INTO labeling_statistics (
        symbol, timeframe, total_bars, labeled_bars, label_distribution, 
        avg_return_by_label, exit_reasons, avg_holding_period, 
        processing_time_ms, data_quality_score, sharpe_ratio, 
        win_rate, profit_factor, run_timestamp
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)

processing_state_repo:
  insert_processing_state: |
    INSERT INTO processing_state (instrument_id, process_type, completed_at, metadata, status)
    VALUES ($1, $2, $3, $4, $5)
    ON CONFLICT (instrument_id, process_type)
    DO UPDATE SET
        completed_at = EXCLUDED.completed_at,
        metadata = EXCLUDED.metadata,
        status = EXCLUDED.status
  check_processing_complete: |
    SELECT EXISTS(
        SELECT 1 FROM processing_state 
        WHERE instrument_id = $1 AND process_type = $2 AND status = 'completed'
    )
  check_processing_failed: |
    SELECT EXISTS(
        SELECT 1 FROM processing_state 
        WHERE instrument_id = $1 AND process_type = $2 AND status = 'failed'
    )
  check_processing_in_progress: |
    SELECT EXISTS(
        SELECT 1 FROM processing_state 
        WHERE instrument_id = $1 AND process_type = $2 AND status = 'in_progress'
    )
  get_processing_status: |
    SELECT status, completed_at, metadata
    FROM processing_state
    WHERE instrument_id = $1 AND process_type = $2
    ORDER BY completed_at DESC
    LIMIT 1
  get_last_processing_timestamp: |
    SELECT completed_at
    FROM processing_state
    WHERE instrument_id = $1 AND process_type = $2
  delete_specific_processing_state: |
    DELETE FROM processing_state
    WHERE instrument_id = $1 AND process_type = $2
  delete_processing_state_by_instrument: |
    DELETE FROM processing_state
    WHERE instrument_id = $1
  delete_all_processing_state: |
    DELETE FROM processing_state
  
  # System operations queries
  check_system_operation_complete: |
    SELECT COUNT(*) > 0 
    FROM system_operations_state 
    WHERE operation_type = $1 AND status = 'completed'
  
  upsert_system_operation: |
    INSERT INTO system_operations_state (operation_type, completed_at, metadata, status, updated_at)
    VALUES ($1, $2, $3, $4, $5)
    ON CONFLICT (operation_type) 
    DO UPDATE SET 
      completed_at = EXCLUDED.completed_at,
      metadata = EXCLUDED.metadata,
      status = EXCLUDED.status,
      updated_at = EXCLUDED.updated_at
  
  get_processing_summary: |
    SELECT instrument_id, process_type, completed_at
    FROM processing_state
    ORDER BY completed_at DESC
  get_instruments_needing_processing: |
    SELECT DISTINCT i.instrument_id
    FROM instruments i
    LEFT JOIN processing_state ps ON i.instrument_id = ps.instrument_id AND ps.process_type = $1
    WHERE ps.instrument_id IS NULL
  cleanup_old_processing_state: |
    DELETE FROM processing_state
    WHERE completed_at < NOW() - INTERVAL '%s days'
  upsert_data_range: |
    INSERT INTO data_ranges (instrument_id, timeframe, earliest_ts, latest_ts, last_updated)
    VALUES ($1, $2, $3, $4, $5)
    ON CONFLICT (instrument_id, timeframe)
    DO UPDATE SET
        earliest_ts = LEAST(data_ranges.earliest_ts, EXCLUDED.earliest_ts),
        latest_ts = GREATEST(data_ranges.latest_ts, EXCLUDED.latest_ts),
        last_updated = EXCLUDED.last_updated
  get_data_range: |
    SELECT earliest_ts, latest_ts
    FROM data_ranges
    WHERE instrument_id = $1 AND timeframe = $2
  delete_data_ranges_by_instrument: |
    DELETE FROM data_ranges
    WHERE instrument_id = $1
  delete_all_data_ranges: |
    DELETE FROM data_ranges
  get_data_ranges_summary: |
    SELECT instrument_id, timeframe, earliest_ts, latest_ts, last_updated
    FROM data_ranges
    ORDER BY last_updated DESC
  get_all_processing_states: |
    SELECT instrument_id, process_type as processing_type, completed_at, metadata 
    FROM processing_state
  get_all_data_ranges: |
    SELECT instrument_id, timeframe, earliest_ts, latest_ts 
    FROM data_ranges
  check_historical_data_availability: |
    SELECT COUNT(*) as count FROM ohlcv_1min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{lookback_days} days'
  check_aggregation_data_availability: |
    SELECT COUNT(*) as count FROM ohlcv_1min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{lookback_days} days'
  check_aggregated_timeframe_data: |
    SELECT COUNT(*) as count FROM ohlcv_{timeframe}min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{lookback_days} days'
  check_features_timeframe_data: |
    SELECT COUNT(*) as count FROM ohlcv_{timeframe}min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{lookback_days} days'
  check_existing_features: |
    SELECT COUNT(DISTINCT ts) as count FROM features
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{lookback_days} days'
  check_labeling_ohlcv_data: |
    SELECT COUNT(*) as count FROM ohlcv_{timeframe}min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{lookback_days} days'
  check_labeling_features_data: |
    SELECT COUNT(DISTINCT ts) as count FROM features
    WHERE instrument_id = $1 AND timeframe = $2
    AND ts >= NOW() - INTERVAL '{lookback_days} days'
  check_existing_labels: |
    SELECT COUNT(*) as count FROM labels
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{lookback_days} days'
  has_actual_data_historical_fetch: |
    SELECT COUNT(*) as count FROM ohlcv_1min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{historical_data_availability_days} days'
  has_actual_data_aggregation: |
    SELECT COUNT(*) as count FROM ohlcv_1min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{aggregation_data_availability_days} days'
  has_actual_data_features: |
    SELECT COUNT(*) as count FROM ohlcv_{timeframe}min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{features_data_availability_days} days'
  has_actual_data_labeling: |
    SELECT COUNT(*) as count FROM ohlcv_{timeframe}min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{labeling_data_availability_days} days'
  has_actual_data_aggregated_timeframe: |
    SELECT COUNT(*) as count FROM ohlcv_{timeframe}min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{features_data_availability_days} days'
  has_actual_data_features_timeframe: |
    SELECT COUNT(*) as count FROM ohlcv_{timeframe}min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{features_data_availability_days} days'
  has_actual_data_existing_features: |
    SELECT COUNT(DISTINCT ts) as count FROM features
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{existing_features_availability_days} days'
  has_actual_data_labeling_ohlcv: |
    SELECT COUNT(*) as count FROM ohlcv_{timeframe}min
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{labeling_data_availability_days} days'
  has_actual_data_labeling_features: |
    SELECT COUNT(DISTINCT ts) as count FROM features
    WHERE instrument_id = $1 AND timeframe = $2
    AND ts >= NOW() - INTERVAL '{labeling_data_availability_days} days'
  has_actual_data_existing_labels: |
    SELECT COUNT(*) as count FROM labels
    WHERE instrument_id = $1
    AND ts >= NOW() - INTERVAL '{existing_labels_availability_days} days'

ohlcv_repo:
  insert_ohlcv_data: |
    INSERT INTO {table_name} (ts, instrument_id, open, high, low, close, volume, oi)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    ON CONFLICT (instrument_id, ts) DO UPDATE
    SET open = EXCLUDED.open,
        high = EXCLUDED.high,
        low = EXCLUDED.low,
        close = EXCLUDED.close,
        volume = EXCLUDED.volume,
        oi = EXCLUDED.oi
  get_ohlcv_data: "SELECT ts, open, high, low, close, volume, oi FROM {table_name} WHERE instrument_id = $1 AND ts BETWEEN $2 AND $3 ORDER BY ts ASC"
  get_latest_candle: "SELECT ts, open, high, low, close, volume, oi FROM {table_name} WHERE instrument_id = $1 ORDER BY ts DESC LIMIT 1"
  get_ohlcv_data_for_features: "SELECT ts, open, high, low, close, volume, oi FROM {table_name} WHERE instrument_id = $1 ORDER BY ts DESC LIMIT $2"
  check_data_availability: "SELECT COUNT(*) as candle_count FROM {table_name} WHERE ts >= $1 AND ts <= $2"
  get_data_range: |
    SELECT MIN(ts) as earliest_ts, MAX(ts) as latest_ts
    FROM {table_name}
    WHERE instrument_id = $1
  get_data_range_for_instrument: |
    SELECT MIN(ts) as earliest_ts, MAX(ts) as latest_ts
    FROM {table_name}
    WHERE instrument_id = $1

data_reset_repo:
  check_table_exists: |
    SELECT EXISTS (
      SELECT 1 FROM information_schema.tables 
      WHERE table_schema = 'public' AND table_name = $1
    )
  truncate_table: |
    TRUNCATE TABLE {table_name} CASCADE
  get_all_tables: |
    SELECT table_name 
    FROM information_schema.tables 
    WHERE table_schema = 'public' AND table_type = 'BASE TABLE'
    ORDER BY table_name
  get_table_row_count: |
    SELECT COUNT(*) as row_count FROM {table_name}
