# Docker Makefile for Algo Trading System
.PHONY: help build build-dev build-base build-prod build-rebuild up up-dev up-prod down down-dev clean logs logs-dev shell shell-dev db-shell prometheus grafana

# Image configuration
BASE_IMAGE_NAME := algo-trading-base
BASE_IMAGE_TAG := latest
PROD_IMAGE_NAME := algo-trade-algo-trade-app
PROD_IMAGE_TAG := latest

# Default target
help:
	@echo "Available commands:"
	@echo ""
	@echo "ðŸ—ï¸  BUILD COMMANDS:"
	@echo "  build-base     - Build base image with dependencies (slow, run when deps change)"
	@echo "  build-prod     - Build production image (fast, uses base image)"
	@echo "  build          - Smart build (builds base if needed, then prod)"
	@echo "  build-rebuild  - Force rebuild both base and production images"
	@echo "  build-dev      - Build development image"
	@echo ""
	@echo "ðŸš€ ENVIRONMENT COMMANDS:"
	@echo "  up         - Start production environment"
	@echo "  up-dev     - Start development environment with hot reloading"
	@echo "  up-prod    - Start full production environment"
	@echo "  down       - Stop production containers"
	@echo "  down-dev   - Stop development containers"
	@echo ""
	@echo "ðŸ”§ UTILITY COMMANDS:"
	@echo "  clean      - Remove containers, volumes, and images"
	@echo "  logs       - View production logs"
	@echo "  logs-dev   - View development logs"
	@echo "  shell      - Access production container shell"
	@echo "  shell-dev  - Access development container shell"
	@echo "  db-shell   - Access TimescaleDB shell"
	@echo "  prometheus - Open Prometheus in browser"
	@echo "  grafana    - Open Grafana in browser"

# ============================================================================
# OPTIMIZED BUILD SYSTEM
# Two-stage build: base image (dependencies) + production image (code)
# ============================================================================

# Check if base image exists
check-base:
	@if docker image inspect $(BASE_IMAGE_NAME):$(BASE_IMAGE_TAG) >/dev/null 2>&1; then \
		echo "âœ… Base image $(BASE_IMAGE_NAME):$(BASE_IMAGE_TAG) exists"; \
	else \
		echo "âŒ Base image $(BASE_IMAGE_NAME):$(BASE_IMAGE_TAG) not found"; \
		echo "ðŸ”¨ Run 'make build-base' to build it first"; \
		exit 1; \
	fi

# Build base image with system and Python dependencies (slow, run when deps change)
build-base:
	@echo "ðŸ”¨ Building base image with dependencies..."
	@echo "â±ï¸  This may take a while for the first build..."
	docker build -f Dockerfile.base -t $(BASE_IMAGE_NAME):$(BASE_IMAGE_TAG) .
	@echo "âœ… Base image built successfully!"
	@echo "ðŸ“Š Base image size:"
	@docker images $(BASE_IMAGE_NAME):$(BASE_IMAGE_TAG) --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

# Build production image (fast, uses base image)
build-prod: check-base
	@echo "ðŸš€ Building production image (fast build)..."
	docker build -f Dockerfile.prod -t $(PROD_IMAGE_NAME):$(PROD_IMAGE_TAG) .
	@echo "âœ… Production image built successfully!"
	@echo "ðŸ“Š Production image size:"
	@docker images $(PROD_IMAGE_NAME):$(PROD_IMAGE_TAG) --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

# Smart build: build base only if needed, then build production
build-base-if-needed:
	@if ! docker image inspect $(BASE_IMAGE_NAME):$(BASE_IMAGE_TAG) >/dev/null 2>&1; then \
		echo "ðŸ”¨ Base image not found, building..."; \
		$(MAKE) build-base; \
	else \
		echo "âœ… Base image exists, skipping build"; \
	fi

# Main build command (smart build)
build: build-base-if-needed build-prod

# Force rebuild both images (when dependencies change)
build-rebuild:
	@echo "ðŸ”„ Force rebuilding both base and production images..."
	docker build --no-cache -f Dockerfile.base -t $(BASE_IMAGE_NAME):$(BASE_IMAGE_TAG) .
	docker build --no-cache -f Dockerfile.prod -t $(PROD_IMAGE_NAME):$(PROD_IMAGE_TAG) .
	@echo "âœ… Both images rebuilt successfully!"
	@echo "ðŸ“Š Image sizes:"
	@docker images | grep -E "($(BASE_IMAGE_NAME)|$(PROD_IMAGE_NAME))" | head -2

# Build development image
build-dev:
	docker compose -f docker-compose.dev.yml build

# Start production environment (with smart build)
up: build
	@echo "Creating data directories..."
	@mkdir -p data/timescaledb data/prometheus data/grafana
	docker-compose up -d
	@echo "âœ… Production environment started."
	@echo "Services available at:"
	@echo "  - Application: http://localhost:8000"
	@echo "  - Grafana: http://localhost:3000 (admin/admin123)"
	@echo "  - Prometheus: http://localhost:9090"
	@echo "  - TimescaleDB: localhost:15432"
	@echo ""
	@echo "ðŸ“œ View logs: make logs"
	@echo "ðŸ” Check health: make health"

# Start development environment with hot reloading
up-dev:
	@echo "Creating data directories..."
	@mkdir -p data/dev/timescaledb
	docker compose -f docker-compose.dev.yml up -d
	@echo "Development environment with hot reloading started."
	@echo "Services available at:"
	@echo "  - Application: http://localhost:8000 (auto-restarts on code changes)"
	@echo "  - TimescaleDB: localhost:15432"
	@echo ""
	@echo "ðŸ’¡ Edit any Python file to see auto-restart in action!"
	@echo "ðŸ“‹ View logs with: make logs-dev"

# Start production environment
up-prod:
	@echo "Creating data directories..."
	@mkdir -p data/timescaledb data/prometheus data/grafana
	docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
	@echo "Production environment started."
	@echo "Services available at:"
	@echo "  - Application: http://localhost:8000"
	@echo "  - Grafana: http://localhost:3000"
	@echo "  - Prometheus: http://localhost:9090"
	@echo "  - TimescaleDB: localhost:5432"

# Stop production containers
down:
	docker-compose down

# Stop development containers
down-dev:
	docker compose -f docker-compose.dev.yml down

# Clean up everything (containers, volumes, images)
clean:
	docker compose down -v --rmi all
	
	@echo "All Docker resources cleaned up."

# View production logs
logs:
	docker-compose logs -f

# View development logs
logs-dev:
	docker compose -f docker-compose.dev.yml logs -f

# Access production container shell
shell:
	docker-compose exec algo-trade-app /bin/bash

# Access development container shell
shell-dev:
	docker compose -f docker-compose.dev.yml exec algo-trade-app-dev /bin/bash

# Access database shell
db-shell:
	docker-compose exec timescaledb psql -U algo_trader -d algo_trade_db

# Open Prometheus in browser
prometheus:
	@echo "Opening Prometheus at http://localhost:9090"
	@command -v xdg-open >/dev/null 2>&1 && xdg-open http://localhost:9090 || echo "Please open http://localhost:9090 manually"

# Open Grafana in browser
grafana:
	@echo "Opening Grafana at http://localhost:3000"
	@echo "Default credentials: admin/admin123"
	@command -v xdg-open >/dev/null 2>&1 && xdg-open http://localhost:3000 || echo "Please open http://localhost:3000 manually"

# Health check
health:
	@echo "Checking service health..."
	@docker-compose ps
	@echo ""
	@echo "Application health:"
	@curl -s http://localhost:8000/health || echo "Application not responding"
	@echo ""
	@echo "Prometheus health:"
	@curl -s http://localhost:9090/-/healthy || echo "Prometheus not responding"
	@echo ""
	@echo "Grafana health:"
	@curl -s http://localhost:3000/api/health || echo "Grafana not responding"

# Backup database
backup-db:
	@echo "Creating database backup..."
	@mkdir -p backups
	docker-compose exec timescaledb pg_dump -U algo_trader -d algo_trade_db > backups/backup_$(shell date +%Y%m%d_%H%M%S).sql
	@echo "Database backup created in backups/"

# Restore database
restore-db:
	@echo "Available backups:"
	@ls -la backups/*.sql 2>/dev/null || echo "No backups found"
	@echo "Usage: make restore-db BACKUP=backups/backup_YYYYMMDD_HHMMSS.sql"
ifdef BACKUP
	docker-compose exec -T timescaledb psql -U algo_trader -d algo_trade_db < $(BACKUP)
	@echo "Database restored from $(BACKUP)"
else
	@echo "Please specify BACKUP file: make restore-db BACKUP=backups/backup_YYYYMMDD_HHMMSS.sql"
endif

# ============================================================================
# ADDITIONAL UTILITY COMMANDS FOR OPTIMIZED WORKFLOW
# ============================================================================

# Quick restart after code changes (fast)
restart-app: build-prod
	@echo "ðŸ”„ Restarting application container..."
	docker-compose down algo-trade-app
	docker-compose up -d algo-trade-app
	@echo "âœ… Application container restarted!"

# Development workflow: build and start with logs
dev: build up logs

# Show Docker system info and image sizes
info:
	@echo "ðŸ³ Docker system information:"
	@echo "============================================"
	@docker system df
	@echo ""
	@echo "ðŸ“Š Current containers:"
	@docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
	@echo ""
	@echo "ðŸ–¼ï¸  Algo-trading images:"
	@docker images | grep -E "($(BASE_IMAGE_NAME)|$(PROD_IMAGE_NAME)|algo-trade)" || echo "No algo-trading images found"

# Clean up all algo-trading related Docker resources
clean-all:
	@echo "ðŸ§¹ Cleaning up all algo-trading Docker resources..."
	docker-compose down -v --rmi all
	-docker rmi $(BASE_IMAGE_NAME):$(BASE_IMAGE_TAG) 2>/dev/null
	-docker rmi $(PROD_IMAGE_NAME):$(PROD_IMAGE_TAG) 2>/dev/null
	docker system prune -f
	@echo "âœ… All resources cleaned up!"

# Update .PHONY targets
.PHONY: check-base build-base build-prod build-base-if-needed build-rebuild restart-app dev info clean-all